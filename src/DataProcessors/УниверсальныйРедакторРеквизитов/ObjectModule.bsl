Перем ТаблицаТиповМетаОбъектов Экспорт;


// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Процедура РедактироватьОбъектСсылки(пСсылка) Экспорт 

	ПолучитьФормуСсылки(пСсылка).Открыть();

КонецПроцедуры // РедактироватьОбъектСсылки()

// <Описание процедуры>
//
// Параметры:
//  <Параметр1>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>;
//  <Параметр2>  – <Тип.Вид> – <описание параметра>
//                 <продолжение описания параметра>.
//
Функция ПолучитьФормуСсылки(пСсылка) Экспорт 

	Форма = ПолучитьФорму();
	Форма.ВыбОбъект = пСсылка;
	Возврат Форма;

КонецФункции // РедактироватьОбъектСсылки()

// Получает менеджер по описанию типов, типу, метаданным, ссылке или объекту.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем менеджер.
//
// Возвращаемое значение:
//               – МенеджерОбъекта - для ссылки или ссылочного типа;
//  Неопределено - не удалось получить.
//
Функция ЛксПолучитьМенеджер(пОбъект) Экспорт
	
	Если ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда 
		МетаданныеОбъекта = пОбъект;
	Иначе
		МетаданныеОбъекта = ЛксПолучитьМетаданные(пОбъект);
	КонецЕсли;
	КорневойТип = ЛксПолучитьКорневойТипКонфигурации(МетаданныеОбъекта, Истина);
	Если КорневойТип <> Неопределено Тогда 
		Возврат Новый (КорневойТип + "Менеджер." + МетаданныеОбъекта.Имя);
	Иначе
		Возврат Неопределено
	КонецЕсли;

КонецФункции // ЛксПолучитьМенеджер()

// Получает метаданные по полному имени, описанию типов, типу, ссылке или объекту.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем метаданные.
//
// Возвращаемое значение:
//               – Метаданные - полученные;
//  Неопределено - не удалось получить метаданные.
//
Функция ЛксПолучитьМетаданные(пОбъект) Экспорт
	
	Если ТипЗнч(пОбъект) = Тип("Строка") Тогда
		Если ПустаяСтрока(пОбъект) Тогда
			Результат = Неопределено;
		Иначе
			Результат = Метаданные.НайтиПоПолномуИмени(пОбъект);
		КонецЕсли;
		Возврат Результат;
	КонецЕсли;
	ТипОбъекта = ЛксПолучитьТипОбъекта(пОбъект);
	Результат = Метаданные.НайтиПоТипу(ТипОбъекта);
	Возврат Результат;
	
КонецФункции // ЛксПолучитьМетаданные()

// Определяет корневой тип конфигурации по описанию типов, типу, метаданным, ссылке или объекту.
// Для описания типов берется первый тип массива типов.
//
// Параметры:
//  пОбъект      – Произвольный – для чего получаем метаданные;
//  *пЛиТолькоДляКорневого - Булево, *Ложь - возвращать только для объекта корневого типа.
//
// Возвращаемое значение:
//               - Строка – имя типа корневого объекта метаданных;
//  Неопределено - не удалось получить имя типа.
//
Функция ЛксПолучитьКорневойТипКонфигурации(пОбъект, пЛиТолькоДляКорневого = Ложь) Экспорт

	Если ТипЗнч(пОбъект) = Тип("ОбъектМетаданных") Тогда 
		МетаданныеТипа = пОбъект;
	Иначе
		МетаданныеТипа = ЛксПолучитьМетаданные(пОбъект);
	КонецЕсли;
	Результат = Неопределено;
	Если МетаданныеТипа <> Неопределено Тогда
		ПолноеИмя = МетаданныеТипа.ПолноеИмя();
		Если пЛиТолькоДляКорневого Тогда 
			МассивФрагментов = ЛксПолучитьМассивИзСтрокиСРазделителем(ПолноеИмя);
			Если МассивФрагментов.Количество() = 2 Тогда
				Результат = МассивФрагментов[0];
			КонецЕсли;
		Иначе
			Результат = ЛксПолучитьПервыйФрагмент(ПолноеИмя);
		КонецЕсли;
	КонецЕсли;
	Если Результат = "ТабличнаяЧасть" Тогда
		// Баг платформы. У внешних метаданных полное имя не включает сам внешний метаобъект
		Результат = Неопределено;
	КонецЕсли; 
	Возврат Результат;
	
КонецФункции // ЛксПолучитьКорневойТипКонфигурации()

// Получает тип из описания типов, типа или значения.
//
// Параметры:
//  пОбъект    – Тип, ОписаниеТипов, Произвольный – проверяемое значение.
//
// Возвращаемое значение:
//  Тип - найденный тип.
//
Функция ЛксПолучитьТипОбъекта(пОбъект)

	ТипОбъекта = Тип("Неопределено");
	ТипПараметра = ТипЗнч(пОбъект);
	Если ТипПараметра = Тип("ОписаниеТипов") Тогда
		Если пОбъект.Типы().Количество() > 0 Тогда 
			ТипОбъекта = пОбъект.Типы()[0];
		КонецЕсли;
	ИначеЕсли ТипПараметра <> Тип("Тип") Тогда 
		ТипОбъекта = ТипПараметра;
	Иначе
		ТипОбъекта = пОбъект;
	КонецЕсли;
	
	Возврат ТипОбъекта;

КонецФункции // ЛксПолучитьТипОбъекта()

// Получает первый фрагмент, отделяемый разделителем от строки.
// Написана для оптимизации по скорости.
// 
// Параметры:
//  пСтрока      - Строка - которую разбиваем;
//  *пРазделитель - Строка, "." - символ-разделитель;
//  *пЛиИспользоватьГраницуЕслиМаркерНеНайден - Булево, *Истина.
//
// Возвращаемое значение:
//               - Строка - первый фрагмент строки;
//  Неопределено - в строке не обнаружен разделитель.
//
Функция ЛксПолучитьПервыйФрагмент(пСтрока, пРазделитель = ".",
	пЛиИспользоватьГраницуЕслиМаркерНеНайден = Истина) Экспорт

	Позиция = Найти(пСтрока, пРазделитель);
	Если Позиция > 0 Тогда
		Возврат Лев(пСтрока, Позиция - 1);
	Иначе
		Если пЛиИспользоватьГраницуЕслиМаркерНеНайден Тогда 
			Возврат пСтрока;
		Иначе
			Возврат пСтрока;
		КонецЕсли;
	КонецЕсли;

КонецФункции // ЛксПолучитьПервыйФрагмент()

// Функция разбивает строку разделителем.
// 
// Параметры:
//  пСтрока      - Строка - которую разбиваем;
//  *пРазделитель - Строка, "." - символ-разделитель;
//  *ОбрезатьНепечатныеСимволы - Булево, *Ложь.
//
// Возвращаемое значение:
//  Массив - фрагментов.
//
Функция ЛксПолучитьМассивИзСтрокиСРазделителем(Знач Стр, Разделитель = ".", ОбрезатьНепечатныеСимволы = Ложь) Экспорт
	
	МассивСтрок = Новый Массив;
	
	//лСтрока = СтрЗаменить(Стр, Разделитель, Символы.ПС);
	//// Баг платформы. СтрЧислоСтрок не учитывает терминальный перевод строки.
	//ЧислоСтрок = СтрЧислоСтрок(лСтрока + " ");
	//Для Счетчик = 1 По ЧислоСтрок Цикл 
	//	Фрагмент = СтрПолучитьСтроку(лСтрока, Счетчик);
	//	Если ОбрезатьНепечатныеСимволы Тогда
	//		Фрагмент = СокрЛП(Фрагмент);
	//	КонецЕсли;
	//	МассивСтрок.Добавить(Фрагмент);
	//КонецЦикла;
	
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				Фрагмент = Стр;
				Если ОбрезатьНепечатныеСимволы Тогда
					Фрагмент = СокрЛП(Фрагмент);
				КонецЕсли;
				МассивСтрок.Добавить(Фрагмент);
				Возврат МассивСтрок;
			КонецЕсли;
			Фрагмент = Лев(Стр,Поз-1);
			Если ОбрезатьНепечатныеСимволы Тогда
				Фрагмент = СокрЛП(Фрагмент);
			КонецЕсли;
			МассивСтрок.Добавить(Фрагмент);
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;

	Возврат МассивСтрок;
		
КонецФункции // ЛксПолучитьМассивИзСтрокиСРазделителем()

// Интерактивно записывает значение в элемент управления. Интерактивность заключается в срабатывании
// события ПриИзменении у элемента управления.
//
// Параметры:
//  ЭлементУправления – ЭлементУправления – которому присваиваем значение;
//  Значение     – Произвольный – присваиваемое значение;
//  *ФормаИнициатор - Форма, *Неопределено - которая будет использована в качестве инициатора события;
//               если не указана, то будет создана временная форма-пустышка.
//
Процедура ЛксИнтерактивноЗаписатьВЭлементУправления(ЭлементУправления, Значение, ФормаИнициатор = Неопределено) Экспорт
    
    Перем СтарыйВладелец, СтарыйЗакрыватьПриВыборе;
    
    Если ФормаИнициатор = Неопределено Тогда
        //ФормаИнициатор = ПолучитьОбщуюФорму("ирПустышка", ЭлементУправления);
		ФормаИнициатор = ПолучитьФорму("ирПустышка", ЭлементУправления);
    Иначе
        СтарыйВладелец = ФормаИнициатор.ВладелецФормы;
        СтарыйЗакрыватьПриВыборе = ФормаИнициатор.ЗакрыватьПриВыборе;
        ФормаИнициатор.ВладелецФормы = ЭлементУправления;
        ФормаИнициатор.ЗакрыватьПриВыборе = Ложь;
    КонецЕсли;
    ФормаИнициатор.ОповеститьОВыборе(Значение); 
    Если СтарыйЗакрыватьПриВыборе <> Неопределено Тогда
        ФормаИнициатор.ВладелецФормы = СтарыйВладелец;
        ФормаИнициатор.ЗакрыватьПриВыборе = СтарыйЗакрыватьПриВыборе;
    КонецЕсли;

КонецПроцедуры // ЛксИнтерактивноЗаписатьВЭлементУправления()

// Получает таблицу единственных и множественных чисел корневых типов.
//
// Параметры:
//  *ЛиВключатьНехранимые - Булево, *Истина - включать ли нехранимые корневые типы;
//  *ЛиВключатьДочерние - Булево, *Истина - включать ли дочерние корневые типы;
//  *ЛиВключатьВнешние - Булево, *Истина - включать ли внешние корневые типы.
//
// Возвращаемое значение:
//  Массив – имен хранимых типов
//
Функция ПолучитьТаблицуТиповМетаОбъектов(ЛиВключатьНехранимые = Истина, ЛиВключатьДочерние = Истина, ЛиВключатьВнешние = Истина) Экспорт

	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Категория", Новый ОписаниеТипов("Число")); // 0 - корневой, 1 - нехранимый, 2 - дочерний, 3 - внешний
	Таблица.Колонки.Добавить("Единственное");
	Таблица.Колонки.Добавить("ИндексКартинкиЕдинственное");
	Таблица.Колонки.Добавить("Множественное");
	Таблица.Колонки.Добавить("ИндексКартинкиМножественное");
	
	// Корневые типы
	Если ЛиВключатьНехранимые Тогда
		// Главным образом эти строки нужны для связи с пиктограммами этих коллекций
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "WebСервис", ,          "WebСервисы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "WSCсылка", ,           "WSСсылки", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Интерфейс", ,          "Интерфейсы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Нумератор", ,          "НумераторыДокументов", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Обработка", 19,        "Обработки", 18);
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщаяФорма", ,         "ОбщиеФормы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщийМакет", ,         "ОбщиеМакеты", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщаяКартинка", ,      "ОбщиеКартинки", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ОбщийМодуль", ,        "ОбщиеМодули", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Отчет", 24,            "Отчеты", 23);
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ПараметрСеанса", ,     "ПараметрыСеанса", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ПакетXDTO", ,          "ПакетыXDTO", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ПодпискаНаСобытия", ,  "ПодпискиНаСобытия", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Подсистема", ,         "Подсистемы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "РегламентноеЗадание", , "РегламентныеЗадания", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Роль", ,               "Роли", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Стиль", ,              "Стили", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "ЭлементСтиля", ,       "ЭлементыСтиля", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 1, "Язык", ,               "Языки", );
	КонецЕсли;
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ПланОбмена", 52,           "ПланыОбмена", 51);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Константа", 12,            "Константы", 11);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Справочник", 3,            "Справочники", 2);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "КритерийОтбора", ,         "КритерииОтбора", );
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Последовательность", ,     "Последовательности", );
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Документ", 13,             "Документы", 12);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ЖурналДокументов", 16,     "ЖурналыДокументов", 15);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Перечисление", 10,         "Перечисления", 9);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ПланВидовХарактеристик", 38, "ПланыВидовХарактеристик", 37);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ПланСчетов", 40,           "ПланыСчетов",39 );
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "ПланВидовРасчета", 48,     "ПланыВидовРасчета", 47);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "РегистрСведений", 34,      "РегистрыСведений", 33);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "РегистрНакопления", 32,    "РегистрыНакопления", 31);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "РегистрБухгалтерии", 42,   "РегистрыБухгалтерии", 41);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "РегистрРасчета", 50,       "РегистрыРасчета", 49);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "БизнесПроцесс", 44,        "БизнесПроцессы", 43);
	ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 0, "Задача", 46,               "Задачи", 45);
	
	// Дочерние типы
	Если ЛиВключатьДочерние Тогда
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Графа", ,                 "Графы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ЗначениеПеречисления", ,  "ЗначенияПеречисления", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Измерение", ,             "Измерения", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Макет", ,                 "Макеты", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Операция", ,              "Операции", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Параметр", ,              "Параметры", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Перерасчет", ,            "Перерасчеты", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ПризнакУчета", ,          "ПризнакиУчета", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ПризнакУчетаСубконто", ,  "ПризнакиУчетаСубконто", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Реквизит", ,              "Реквизиты", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "РеквизитАдресации", ,     "РеквизитыАдресации", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Ресурс", ,                "Ресурсы", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "ТабличнаяЧасть", 55,      "ТабличныеЧасти", 54);
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 2, "Форма", ,                 "Формы", );
	КонецЕсли;
	
	// Внешние типы
	Если ЛиВключатьВнешние Тогда
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 3, "ВнешняяОбработка", ,      "ВнешниеОбработки", );
		ДобавитьВТаблицуТиповМетаОбъектов(Таблица, 3, "ВнешнийОтчет", ,          "ВнешниеОтчеты", );
	КонецЕсли;
	
	Возврат Таблица;

КонецФункции // ПолучитьТаблицуКорневыхОбъектов()

// Добавляет новую строку в таблицу корневых объектов.
//
// Параметры:
//  Таблица      – ТаблицаЗначений;
//  *Категория   - Число, *0;
//  Единственное – Строка;
//  ИндексКартинкиЕдинственное – Число;
//  Множественное – Строка;
//  ИндексКартинкиМножественное – Число;
//
Процедура ДобавитьВТаблицуТиповМетаОбъектов(Таблица, Категория = 0, Единственное, ИндексКартинкиЕдинственное,
	Множественное, ИндексКартинкиМножественное)

	НовыйКорневойОбъект = Таблица.Добавить();
	НовыйКорневойОбъект.Категория = Категория;
	НовыйКорневойОбъект.Единственное = Единственное;
	НовыйКорневойОбъект.ИндексКартинкиЕдинственное = ИндексКартинкиЕдинственное;
	НовыйКорневойОбъект.Множественное = Множественное;
	НовыйКорневойОбъект.ИндексКартинкиМножественное = ИндексКартинкиМножественное;

КонецПроцедуры // ДобавитьВТаблицуТиповМетаОбъектов()

 // Проверяет, является ли строка именем корневого типа объекта БД.
//
// Параметры:
//  пИмяКорневогоТипа - Строка, Неопределено - имя корневого типа.
//
// Возвращаемое значение:
//  Истина       – тип является корневым типом объекта БД;
//  Ложь         – иначе.
//
Функция ЛксЛиКорневойТипОбъектаБД(пИмяКорневогоТипа) Экспорт 

	Если Ложь
		ИЛИ пИмяКорневогоТипа = "БизнесПроцесс" 
		ИЛИ пИмяКорневогоТипа = "Задача" 
		ИЛИ пИмяКорневогоТипа = "Документ"
		ИЛИ пИмяКорневогоТипа = "ПланВидовРасчета" 
		ИЛИ пИмяКорневогоТипа = "ПланВидовХарактеристик" 
		ИЛИ пИмяКорневогоТипа = "ПланОбмена"
		ИЛИ пИмяКорневогоТипа = "ПланСчетов" 
		ИЛИ пИмяКорневогоТипа = "Справочник"
	Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиКорневойТипОбъектаБД()

// Проверяет, является ли строка именем корневого типа регистра БД.
//
// Параметры:
//  пИмяКорневогоТипа - Строка, Неопределено - имя корневого типа.
//
// Возвращаемое значение:
//  Истина       – тип является корневым типом регистра БД;
//  Ложь         – иначе.
//
Функция ЛксЛиКорневойТипРегистраБД(пИмяКорневогоТипа) Экспорт

	Если Ложь
		ИЛИ пИмяКорневогоТипа = "РегистрСведений"
		ИЛИ пИмяКорневогоТипа = "РегистрНакопления"
		ИЛИ пИмяКорневогоТипа = "РегистрБухгалтерии"
		ИЛИ пИмяКорневогоТипа = "РегистрРасчета"
	Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // ЛксЛиКорневойТипРегистраБД()

// Получает строку типа метаобъектов по единственному или множественному числу.
//
// Параметры:
//  *Единственное – Строка, *Неопределено - единственное число типа;
//  *Множественное – Строка, *Неопределено - множественное число типа.
//  *Категория  – Число, *Неопределено.
//
// Возвращаемое значение:
//  СтрокаТаблицыЗначений - найденная строка типа;
//  Неопределено – корневой тип не найден.
//
Функция ПолучитьСтрокуТипаМетаОбъектов(Единственное = Неопределено, Множественное = Неопределено, Категория = Неопределено) Экспорт
	
	СтруктураПоиска = Новый Структура;
	Если Категория <> Неопределено Тогда
		СтруктураПоиска.Вставить("Категория", Категория);
	КонецЕсли;
	Если Единственное = Неопределено Тогда
		СтруктураПоиска.Вставить("Множественное", Множественное);
	Иначе
		СтруктураПоиска.Вставить("Единственное", Единственное);
	КонецЕсли;
	НайденныеСтроки = ТаблицаТиповМетаОбъектов.НайтиСтроки(СтруктураПоиска);
	Если НайденныеСтроки.Количество() = 0 Тогда
		Результат = Неопределено;
	Иначе
		Результат = НайденныеСтроки[0];
	КонецЕсли;
	Возврат Результат;

КонецФункции // ПолучитьСтрокуТипаМетаОбъектов()

// Получает представление из идентификатора по правилу 
// "Дебиторка_По_контрагентамСИнтерваламиСНГДля__Руководства" => "Дебиторка По контрагентам с интервалами СНГ для  Руководства".
// После символа "_" регистр не меняется, а сам символ заменяется на " ".
//
// Параметры:
//  ИсходнаяСтрока – Строка – идентификатор.
//
// Возвращаемое значение:
//               – Строка – представление.
//
Функция ЛксПолучитьПредставлениеИзИдентификатора(ИсходнаяСтрока) Экспорт

	СтрокаВозврата = Сред(ИсходнаяСтрока, 1, 1);
	Для Сч = 2 По СтрДлина(ИсходнаяСтрока) Цикл
		ПредыдущийСимвол = Сред(ИсходнаяСтрока, Сч - 1, 1);
		ТекущийСимвол = Сред(ИсходнаяСтрока, Сч, 1);
		СледующийСимвол = Сред(ИсходнаяСтрока, Сч + 1, 1);
		ПослеследующийСимвол = Сред(ИсходнаяСтрока, Сч + 2, 1);
		Если ТекущийСимвол = "_" Тогда 
			СтрокаВозврата = СтрокаВозврата + " ";
			Продолжить;
		ИначеЕсли Истина
			И ВРЕГ(ТекущийСимвол) = ТекущийСимвол
			// В идентификаторе не должны встречаться пробелы. Поэтому было решено закомментировать следующую строку.
			//И ПредыдущийСимвол <> " "
		Тогда 
			Если Ложь
				ИЛИ ВРЕГ(ПредыдущийСимвол) <> ПредыдущийСимвол
				ИЛИ (Истина 
					И ПредыдущийСимвол <> "_"
					И ВРЕГ(ПредыдущийСимвол) = ПредыдущийСимвол
					И ВРЕГ(СледующийСимвол) <> СледующийСимвол)
			Тогда 
				СтрокаВозврата = СтрокаВозврата + " ";
				Если Ложь
					ИЛИ ВРЕГ(СледующийСимвол) <> СледующийСимвол
					ИЛИ ВРЕГ(ПослеследующийСимвол) <> ПослеследующийСимвол
				Тогда
					ТекущийСимвол = НРЕГ(ТекущийСимвол);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		СтрокаВозврата = СтрокаВозврата + ТекущийСимвол;
	КонецЦикла;
	Возврат СтрокаВозврата;

КонецФункции // ЛксПолучитьПредставлениеИзИдентификатора()

ТаблицаТиповМетаОбъектов = ПолучитьТаблицуТиповМетаОбъектов();
ТаблицаТиповМетаОбъектов.Индексы.Добавить("Единственное,  Категория");
ТаблицаТиповМетаОбъектов.Индексы.Добавить("Множественное, Категория");

